import sys
from unittest.mock import MagicMock
import warnings

# Mock heavy modules before imports
def mock_module(name):
    if name not in sys.modules:
        sys.modules[name] = MagicMock()

modules_to_mock = [
    "torch",
    "torch.nn",
    "torch.nn.functional",
    "torchvision",
    "cv2",
    "skimage",
    "transformers",
    "google-adk",
    "sentence_transformers",
    "accelerate",
    "sam3",
    "sam3.model",
    "sam3.model.sam3_image_processor",
    "triton",
    "spacy",
    "einops",
    "decord",
    "pycocotools",
    "psutil",
    "matplotlib",
    "pandas",
    "scikit-learn"
]

for mod in modules_to_mock:
    mock_module(mod)

# Suppress ResourceWarning for mocked sockets if any
warnings.simplefilter("ignore", ResourceWarning)

import pytest
from pathlib import Path
from fastapi.testclient import TestClient
from app.main import create_app
from app.api.dependencies import get_file_service
from app.services.file_service import FileService
from app.models.schemas import (
    SceneMetadata,
    LightingMetadata,
    AestheticsMetadata,
    PhotographicMetadata
)
from app.api.routes.segmentation import save_result_metadata, get_result
from app.utils.exceptions import NotFoundException, ValidationException

@pytest.fixture
def temp_dirs(tmp_path):
    outputs = tmp_path / "outputs"
    outputs.mkdir()
    target = tmp_path / "target"
    target.mkdir()
    return outputs, target

@pytest.fixture
def client(temp_dirs):
    outputs_dir, _ = temp_dirs

    # Mock FileService
    # We pass mocks for dependencies that might be used by FileService if any
    # FileService constructor might depend on settings which are fine

    # We need to ensure FileService doesn't fail on __init__
    file_service = FileService(outputs_dir=outputs_dir, uploads_dir=outputs_dir)

    app = create_app()
    app.dependency_overrides[get_file_service] = lambda: file_service
    return TestClient(app)

def test_path_traversal_save_metadata(client, temp_dirs):
    outputs_dir, target_dir = temp_dirs

    # Payload for metadata
    metadata = {
        "short_description": "Test",
        "objects": [],
        "background_setting": "None",
        "lighting": {"conditions": "", "direction": "", "shadows": ""},
        "aesthetics": {"composition": "", "color_scheme": "", "mood_atmosphere": "", "preference_score": "", "aesthetic_score": ""},
        "photographic_characteristics": {"depth_of_field": "", "focus": "", "camera_angle": "", "lens_focal_length": ""},
        "style_medium": ""
    }

    # Attempt traversal via API
    # result_id = "../target" -> outputs_dir / "../target" -> target_dir
    # We use encoded slash to try to bypass client-side normalization
    result_id = "..%2Ftarget"

    # Verify target directory is empty initially
    assert not (target_dir / "metadata.json").exists()

    # This might return 404 even if vulnerable due to framework protections,
    # but we assert it doesn't write.
    response = client.post(
        f"/api/v1/results/{result_id}/metadata",
        json=metadata
    )

    # Assert that file was NOT written (this assertion fails if vulnerable AND bypassable)
    if (target_dir / "metadata.json").exists():
        pytest.fail("Vulnerability exploited! metadata.json written to target directory via API.")

    # Assert response code indicates failure
    assert response.status_code in [400, 404, 422, 501], f"Expected error code, got {response.status_code}"

def test_path_traversal_get_result(client, temp_dirs):
    outputs_dir, target_dir = temp_dirs

    # Create a dummy file in target dir to try to read
    (target_dir / "original.png").write_text("secret")

    result_id = "..%2Ftarget"

    response = client.get(f"/api/v1/results/{result_id}")

    # Should be rejected
    assert response.status_code in [400, 404, 422, 501], f"Expected error code, got {response.status_code}"

@pytest.mark.asyncio
async def test_unit_path_traversal_save_metadata(temp_dirs):
    """
    Test the vulnerability directly on the function logic, bypassing FastAPI routing/normalization.
    This ensures the logic itself is secure even if routing changes or if function is called internally.
    """
    outputs_dir, target_dir = temp_dirs

    # Mock FileService
    file_service = FileService(outputs_dir=outputs_dir, uploads_dir=outputs_dir)

    metadata = SceneMetadata(
        short_description="Test",
        objects=[],
        background_setting="None",
        lighting=LightingMetadata(conditions="", direction="", shadows=""),
        aesthetics=AestheticsMetadata(composition="", color_scheme="", mood_atmosphere="", preference_score="", aesthetic_score=""),
        photographic_characteristics=PhotographicMetadata(depth_of_field="", focus="", camera_angle="", lens_focal_length=""),
        style_medium=""
    )
    result_id = "../target"

    # Verify target directory is empty initially
    assert not (target_dir / "metadata.json").exists()

    try:
        # Before fix: This should run without error and write file.
        # After fix: This should raise NotFoundException or ValidationException.
        await save_result_metadata(result_id, metadata, file_service)

        # If no exception raised, check if file was written
        if (target_dir / "metadata.json").exists():
             pytest.fail("Vulnerability exploited! metadata.json written to target directory via internal function call.")

    except (NotFoundException, ValidationException):
        # This is expected behavior AFTER fix
        pass
    except Exception as e:
        # Unexpected error (e.g. permission error, or other)
        pytest.fail(f"Unexpected error: {e}")

@pytest.mark.asyncio
async def test_unit_path_traversal_get_result(temp_dirs):
    """
    Test the vulnerability directly on the function logic for get_result.
    """
    outputs_dir, target_dir = temp_dirs

    # Create a dummy file in target dir to try to read
    (target_dir / "original.png").write_text("secret")

    # Mock FileService and Dependencies
    # get_result needs segmentation_service which has file_service
    segmentation_service = MagicMock()
    file_service = FileService(outputs_dir=outputs_dir, uploads_dir=outputs_dir)
    segmentation_service.file_service = file_service

    result_id = "../target"

    try:
        await get_result(result_id, segmentation_service)
        # If it returns, check if it succeeded (which implies it found the file and returned SegmentationResponse or failed later)
        # The vulnerable code raises 501 Not Implemented at the end if file exists.
        # So catching HTTPException(501) means vulnerability existed (it found the file).
    except Exception as e:
        if isinstance(e, NotFoundException):
            # This is expected behavior AFTER fix
            pass
        elif hasattr(e, "status_code") and e.status_code == 501:
            pytest.fail("Vulnerability exploited! get_result found the file in target directory (raised 501 instead of 404).")
        elif isinstance(e, ValidationException):
            # This is also acceptable AFTER fix
            pass
        else:
            # Other errors
            # If it's something else, maybe it's fine (e.g. mock related), but let's see.
            pass
